# main.py (VERS√ÉO COM WARNING CORRIGIDO)
import asyncio
import logging
import signal
import sys
import pandas as pd
import numpy as np
from datetime import datetime
from typing import Dict, List, Optional
from config_manager import ConfigManager
from risk_manager import RiskManager
from market_analyzer import MarketAnalyzer
from trader import Trader
from profit_tracker import ProfitTracker


class TradingBot:
    def __init__(self, config_path: str = 'config.yaml'):
        """Inicializa o bot de trading com todos os m√≥dulos"""
        self.config_path = config_path
        self.is_running = False
        self.start_time = datetime.now()
        
        # Configura√ß√£o inicial
        self._setup_logging()
        self.logger = logging.getLogger('TradingBot')
        
        # Carrega configura√ß√£o
        self.config_manager = ConfigManager(config_path)
        self.config = self.config_manager.config
        
        # Inicializa m√≥dulos
        self._initialize_modules()
        
        # Configura graceful shutdown
        self._setup_signal_handlers()
        
        self.logger.info("ü§ñ TradingBot inicializado com sucesso")

    def _setup_logging(self):
        """Configura sistema de logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(sys.stdout),
                logging.FileHandler('trading_bot.log', encoding='utf-8')
            ]
        )

    def _initialize_modules(self):
        """Inicializa todos os m√≥dulos do bot"""
        try:
            self.risk_manager = RiskManager(self.config['risk'])
            self.market_analyzer = MarketAnalyzer(self.config['trading'])
            self.trader = Trader(self.config['exchange'])
            self.profit_tracker = ProfitTracker(self.config)
            
            self.logger.info("‚úÖ Todos os m√≥dulos inicializados")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro inicializando m√≥dulos: {e}")
            raise

    def _setup_signal_handlers(self):
        """Configura handlers para graceful shutdown"""
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)

    def _signal_handler(self, signum, frame):
        """Handler para sinais de shutdown"""
        self.logger.info(f"üõë Recebido sinal {signum}, encerrando bot...")
        self.is_running = False

    async def analyze_markets(self) -> List[Dict]:
        """Analisa todos os mercados configurados"""
        signals = []
        symbols = self.config['trading'].get('enabled_pairs', ['BTC/USDT', 'ETH/USDT'])
        
        self.logger.info(f"üîç Analisando {len(symbols)} mercados...")
        
        for symbol in symbols:
            try:
                # Obt√©m dados de mercado
                market_data = await self._get_market_data(symbol)
                if market_data is None:
                    continue

                # Analisa o mercado
                analysis = await self.market_analyzer.analyze_market(symbol, market_data)
                if analysis and analysis.get('signals'):
                    signals.append({
                        'symbol': symbol,
                        'analysis': analysis,
                        'timestamp': datetime.now(),
                        'market_data': market_data
                    })
                    
                    self.logger.info(f"üìà Sinal encontrado para {symbol}: {analysis['signals']}")

            except Exception as e:
                self.logger.error(f"‚ùå Erro analisando {symbol}: {e}")
                continue

        return signals

    async def _get_market_data(self, symbol: str, timeframe: str = '1h', limit: int = 100) -> Optional[pd.DataFrame]:
        """Obt√©m dados de mercado para an√°lise"""
        try:
            # Tenta obter dados reais da exchange
            market_data = await self.trader.get_ohlcv_data(symbol, timeframe, limit)
            
            if market_data is not None and not market_data.empty:
                self.logger.info(f"üìä Dados reais obtidos para {symbol}: {len(market_data)} candles")
                return market_data
            
            # Fallback: dados simulados se n√£o conseguir obter dados reais
            self.logger.warning(f"‚ö†Ô∏è  Usando dados simulados para {symbol}")
            return self._get_simulated_market_data(symbol, timeframe, limit)

        except Exception as e:
            self.logger.error(f"‚ùå Erro obtendo dados para {symbol}: {e}")
            return self._get_simulated_market_data(symbol, timeframe, limit)

    def _get_simulated_market_data(self, symbol: str, timeframe: str = '1h', limit: int = 100) -> pd.DataFrame:
        """Gera dados de mercado simulados para teste"""
        try:
            # Pre√ßos base para diferentes s√≠mbolos
            base_prices = {
                'BTC/USDT': 50000,
                'ETH/USDT': 3000,
                'ADA/USDT': 0.5,
                'BNB/USDT': 400,
                'XRP/USDT': 0.6
            }
            
            base_price = base_prices.get(symbol, 100)
            volatility = 0.02  # 2% de volatilidade
            
            # CORRE√á√ÉO: Use 'h' em vez de 'H' para frequ√™ncia de horas
            dates = pd.date_range(end=datetime.now(), periods=limit, freq='1h')  # CORRIGIDO
            
            prices = [base_price]
            
            for i in range(1, limit):
                change = np.random.normal(0, volatility)
                new_price = prices[-1] * (1 + change)
                prices.append(new_price)
            
            # Cria DataFrame OHLCV
            data = []
            for i, date in enumerate(dates):
                open_price = prices[i]
                close_price = prices[i] * (1 + np.random.normal(0, 0.005))
                high_price = max(open_price, close_price) * (1 + abs(np.random.normal(0, 0.01)))
                low_price = min(open_price, close_price) * (1 - abs(np.random.normal(0, 0.01)))
                volume = np.random.normal(1000, 100)
                
                data.append([date, open_price, high_price, low_price, close_price, volume])
            
            df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df.set_index('timestamp', inplace=True)
            
            self.logger.info(f"üé≤ Dados simulados gerados para {symbol}: {len(df)} candles")
            return df

        except Exception as e:
            self.logger.error(f"‚ùå Erro gerando dados simulados: {e}")
            # Retorna DataFrame vazio como fallback
            return pd.DataFrame(columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    async def execute_trades(self, signals: List[Dict]):
        """Executa trades baseado nos sinais recebidos"""
        if not signals:
            self.logger.info("üì≠ Nenhum sinal para executar")
            return

        self.logger.info(f"üéØ Processando {len(signals)} sinais...")

        for signal_data in signals:
            try:
                symbol = signal_data['symbol']
                analysis = signal_data['analysis']
                
                # Verifica se pode trade
                if not await self.risk_manager.can_trade():
                    self.logger.warning("‚è∏Ô∏è Trading suspenso por gerenciamento de risco")
                    return

                # Prepara dados do mercado
                market = {
                    'symbol': symbol,
                    'current_price': analysis.get('current_price', 0),
                    'volume': analysis.get('volume', 0),
                    'volatility': analysis.get('volatility', 0)
                }

                # Processa cada sinal
                for signal in analysis.get('signals', []):
                    # Log do sinal
                    self.logger.info(f"üì¢ Sinal: {symbol} {signal['action'].upper()} "
                                   f"(For√ßa: {signal['strength']:.2f}) - {signal['description']}")
                    
                    # Executa trade atrav√©s do risk manager
                    trade_result = await self.risk_manager.execute_trade(
                        market=market,
                        signal=signal,
                        trader=self.trader
                    )
                    
                    if trade_result:
                        self.logger.info(f"‚úÖ Trade executado com sucesso: {symbol}")
                        # Atualiza estat√≠sticas
                        await self._update_trading_stats(symbol, signal['action'], True)
                    else:
                        self.logger.info(f"‚è≠Ô∏è Trade n√£o executado para {symbol}")
                        await self._update_trading_stats(symbol, signal['action'], False)

            except Exception as e:
                self.logger.error(f"‚ùå Erro executando trade para {signal_data['symbol']}: {e}")

    async def _update_trading_stats(self, symbol: str, action: str, executed: bool):
        """Atualiza estat√≠sticas de trading"""
        try:
            # Aqui voc√™ pode implementar l√≥gica para salvar estat√≠sticas
            # em banco de dados ou arquivo
            status = "EXECUTADO" if executed else "REJEITADO"
            self.logger.debug(f"üìä Estat√≠stica: {symbol} {action} - {status}")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro atualizando estat√≠sticas: {e}")

    async def monitor_positions(self):
        """Monitora posi√ß√µes abertas e executa sa√≠das"""
        try:
            self.logger.info("üëÄ Monitorando posi√ß√µes abertas...")
            
            # Obter posi√ß√µes abertas do profit tracker
            open_positions = getattr(self.risk_manager.profit_tracker, 'positions', {})
            
            if open_positions:
                open_count = len([p for p in open_positions.values() if p.get('status') == 'open'])
                self.logger.info(f"üìä Posi√ß√µes abertas: {open_count}")
                
                # Verifica condi√ß√µes de sa√≠da para cada posi√ß√£o aberta
                for position_id, position in open_positions.items():
                    if position.get('status') == 'open':
                        await self._check_exit_conditions(position_id, position)
            else:
                self.logger.info("üíº Nenhuma posi√ß√£o aberta")
                    
        except Exception as e:
            self.logger.error(f"‚ùå Erro monitorando posi√ß√µes: {e}")

    async def _check_exit_conditions(self, position_id: str, position: Dict):
        """Verifica condi√ß√µes de sa√≠da para uma posi√ß√£o"""
        try:
            symbol = position.get('symbol')
            current_price = await self.trader.get_current_price(symbol)
            
            if not current_price:
                return

            entry_price = position.get('entry_price', 0)
            side = position.get('side', 'buy')
            
            # Calcula P&L atual
            if side == 'buy':
                pnl_percent = (current_price - entry_price) / entry_price * 100
            else:  # sell (short)
                pnl_percent = (entry_price - current_price) / entry_price * 100
            
            # Condi√ß√µes de sa√≠da
            take_profit = 2.0  # 2%
            stop_loss = -1.0   # -1%
            
            if pnl_percent >= take_profit:
                self.logger.info(f"üéØ Take profit atingido para {symbol}: {pnl_percent:.2f}%")
                await self._close_position(position_id, position, current_price, "TAKE_PROFIT")
            elif pnl_percent <= stop_loss:
                self.logger.warning(f"üõë Stop loss atingido para {symbol}: {pnl_percent:.2f}%")
                await self._close_position(position_id, position, current_price, "STOP_LOSS")
            else:
                self.logger.debug(f"üìà Posi√ß√£o {symbol}: {pnl_percent:.2f}%")
                
        except Exception as e:
            self.logger.error(f"‚ùå Erro verificando condi√ß√µes de sa√≠da: {e}")

    async def _close_position(self, position_id: str, position: Dict, current_price: float, reason: str):
        """Fecha uma posi√ß√£o aberta"""
        try:
            symbol = position.get('symbol')
            side = position.get('side', 'buy')
            
            # Determina a√ß√£o oposta para fechar
            close_side = 'sell' if side == 'buy' else 'buy'
            amount = position.get('size', 0)
            
            if amount <= 0:
                self.logger.error(f"‚ùå Quantidade inv√°lida para fechar posi√ß√£o: {amount}")
                return

            # Executa ordem para fechar posi√ß√£o
            close_order = await self.trader.place_market_order(symbol, close_side, amount)
            
            if close_order:
                # Registra sa√≠da no profit tracker
                await self.risk_manager.profit_tracker.record_exit(
                    position_id, current_price, reason
                )
                self.logger.info(f"‚úÖ Posi√ß√£o fechada: {symbol} {close_side} - Motivo: {reason}")
            else:
                self.logger.error(f"‚ùå Falha ao fechar posi√ß√£o: {symbol}")
                
        except Exception as e:
            self.loglogger.error(f"‚ùå Erro fechando posi√ß√£o: {e}")

    async def generate_report(self):
        """Gera relat√≥rio completo do bot"""
        try:
            runtime = datetime.now() - self.start_time
            
            report = {
                'runtime': str(runtime),
                'start_time': self.start_time.isoformat(),
                'status': 'running' if self.is_running else 'stopped',
                'modules_healthy': True
            }
            
            # Adiciona relat√≥rio de risco
            risk_report = await self.risk_manager.get_risk_report()
            report.update({'risk_report': risk_report})
            
            # Adiciona estat√≠sticas do trader
            trader_stats = self.trader.get_trading_stats()
            report.update({'trader_stats': trader_stats})
            
            self.logger.info("üìä RELAT√ìRIO DO BOT:")
            self.logger.info(f"   ‚è±Ô∏è  Tempo de execu√ß√£o: {runtime}")
            self.logger.info(f"   üéØ Status: {report['status']}")
            self.logger.info(f"   üìà Trades hoje: {risk_report['daily_trades']}/{risk_report['max_daily_trades']}")
            self.logger.info(f"   üí∞ P&L Di√°rio: ${risk_report['daily_pnl']:.2f}")
            self.logger.info(f"   üîÑ Total de ordens: {trader_stats['total_orders']}")
            self.logger.info(f"   ‚úÖ Ordens bem-sucedidas: {trader_stats['successful_orders']}")
            
            return report
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro gerando relat√≥rio: {e}")
            return {}

    async def health_check(self):
        """Verifica sa√∫de de todos os m√≥dulos"""
        try:
            health_status = {
                'bot': 'healthy',
                'risk_manager': 'healthy',
                'market_analyzer': 'healthy',
                'trader': 'healthy',
                'profit_tracker': 'healthy'
            }
            
            # Testa conex√£o com a exchange
            trader_healthy = await self.trader.test_connection()
            if not trader_healthy:
                health_status['trader'] = 'unhealthy'
                health_status['bot'] = 'degraded'
            
            self.logger.info("‚ù§Ô∏è  Health Check:")
            for module, status in health_status.items():
                self.logger.info(f"   {module}: {status}")
            
            return health_status
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro no health check: {e}")
            return {'bot': 'unhealthy'}

    async def run(self):
        """Loop principal do bot"""
        self.is_running = True
        self.start_time = datetime.now()
        
        self.logger.info("üöÄ Iniciando TradingBot...")
        self.logger.info(f"‚≠ê Configura√ß√£o: {self.config['trading'].get('strategy', 'Padr√£o')}")
        self.logger.info(f"üí∞ Par√¢metros de Risco: {self.config['risk']}")

        # Health check inicial
        health = await self.health_check()
        if health['bot'] == 'unhealthy':
            self.logger.error("‚ùå Bot n√£o est√° saud√°vel. Encerrando...")
            return

        iteration = 0
        
        try:
            while self.is_running:
                iteration += 1
                self.logger.info(f"üîÑ Itera√ß√£o #{iteration}")
                
                # 1. Health check peri√≥dico
                if iteration % 10 == 0:
                    await self.health_check()
                
                # 2. An√°lise de mercado
                signals = await self.analyze_markets()
                
                # 3. Execu√ß√£o de trades
                await self.execute_trades(signals)
                
                # 4. Monitoramento de posi√ß√µes
                await self.monitor_positions()
                
                # 5. Relat√≥rio peri√≥dico
                if iteration % 5 == 0:  # A cada 5 itera√ß√µes
                    await self.generate_report()
                    self.risk_manager.show_portfolio_status()
                
                # 6. Aguarda pr√≥ximo ciclo
                interval = self.config['trading'].get('analysis_interval', 60)
                self.logger.info(f"‚è∞ Aguardando {interval} segundos...")
                await asyncio.sleep(interval)
                
        except Exception as e:
            self.logger.error(f"‚ùå Erro cr√≠tico no loop principal: {e}")
            
        finally:
            await self.shutdown()

    async def shutdown(self):
        """Desligamento graceful do bot"""
        self.is_running = False
        self.logger.info("üõë Encerrando TradingBot...")
        
        # Fecha conex√£o com a exchange
        await self.trader.close()
        
        # Gera relat√≥rio final
        final_report = await self.generate_report()
        self.logger.info("üìã RELAT√ìRIO FINAL:")
        for key, value in final_report.items():
            if key != 'risk_report' and key != 'trader_stats':
                self.logger.info(f"   {key}: {value}")
        
        self.logger.info("üëã TradingBot encerrado com sucesso")


async def main():
    """Fun√ß√£o principal"""
    try:
        # Inicializa e executa o bot
        bot = TradingBot()
        await bot.run()
        
    except KeyboardInterrupt:
        print("\nüëã Encerrado pelo usu√°rio")
        
    except Exception as e:
        logging.error(f"‚ùå Erro fatal: {e}")
        sys.exit(1)


if __name__ == "__main__":
    # Configura event loop para Windows (se necess√°rio)
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
    
    # Executa o bot
    asyncio.run(main())
